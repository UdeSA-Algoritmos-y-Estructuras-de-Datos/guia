\documentclass[titlepage,oneside]{book}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{mathabx}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{booktabs}
\usepackage[english,spanish,es-noindentfirst,es-nosectiondot,es-nolists,
es-noshorthands,es-lcroman,es-tabla]{babel}
\usepackage{lmodern}             % Use Latin Modern fonts
\usepackage[T1]{fontenc}         % Better output when a diacritic/accent is used
\usepackage[utf8]{inputenc}      % Allows to input accented characters
\usepackage{textcomp}            % Avoid conflicts with siunitx and microtype
\usepackage{microtype}           % Improves justification and typography
\usepackage[svgnames]{xcolor}    % Svgnames option loads navy (blue) colour
\usepackage[hidelinks,urlcolor=blue]{hyperref}
\hypersetup{colorlinks=true, allcolors=Navy, pdfstartview={XYZ null null 1}}
\newtheorem{lemma}{Lema}
\usepackage[width=14cm,left=3.5cm,marginparwidth=3cm,marginparsep=0.35cm,
height=21cm,top=3.7cm,headsep=1cm, headheight=1.6cm,footskip=1.2cm]{geometry}
\usepackage{csquotes}
\usepackage{biblatex}
\addbibresource{informe.bib}

\title{
	Algoritmos \& Estructuras de Datos\\
	\large Guía Práctica \\
	\large Universidad de San Andrés
}
\author{Magalí Marijuán\\
	\and
	I. Javier Mermet
	\and
	Matías Sandacz
}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\part{Introducción}
\chapter{Lenguaje C}

\begin{enumerate}

    %Ejercicios sin punteros
    \section{Introductorios}

    \item Escribir la función que dado n $\in$ N devuelve si es primo. Recuerden que un número es primo si los únicos divisores que tiene son 1 y el mismo.
    
    \item Escribir la función que dado n $\in$ N devuelve la suma de todos los números impares menores que n.

    %Ejercicios para familiarizarse con punteros
    \section{Punteros y Arreglos}

    \item ¿Cuál es el valor de \textit{a} y \textit{b} luego de ejecutar el programa?
    \begin{minted}{c}
        void myFunc(int* a, int b)
        {
        (*a)++;
        b++;
        }

        void main()
        {
            int a = 10;
            int b = 10;
            myFunc(&a, b);
        }
    \end{minted}

    \item ¿Que valor se imprime por consola luego de cada llamado a \textit{printf}?
    \begin{minted}{c}
        void main()
        {
           int x = 10;
           int* px = &x;
    
           printf("%d \n", px);
           printf("%d \n", (*px));
    
           (*px)++;
    
           printf("%d \n", px);
           printf("%d \n", (*px));
        }
    \end{minted}

    \item Programar las siguientes funciones en C:
    \begin{enumerate}
        \item\mint{c}|void crearArreglo(int v)|
        Crea un arreglo estático de enteros de tamaño 8, inicializando todos sus elementos con $v$, y lo imprime en pantalla.
        
        \item\mint{c}|int* crearArregloDinamico(int n)|
        Dado un natural $n$, crea un arreglo dinámico de enteros de ese tamaño, lo inicializa con ceros, y devuelve un puntero al mismo.
        
        \item Invocar la siguiente función con cualquiera de los arreglos inicializados anteriormente y convencerse de que sus elementos están ubicados de manera \textbf{contigua} en memoria. \textit{Recordar que cada elemento de tipo int ocupa $4$ bytes.}
        
    \begin{minted}{c}
    void mostrarMemoria(int* arr, int size)
    {
        for(int i=0; i<size; i++)
        {
            printf("Elemento: %d, Direccion: %d\n", i, &arr[i]);
        }
    }
    \end{minted}
    \end{enumerate}

    % Ejercicios integradores con arreglos
    \section{Más arreglos!}

    \item Programar las siguientes funciones en C:
    \begin{enumerate}
        \item\mint{c}|int maximo(int* arr, int size)|
        Dado un arreglo de enteros $arr$ de tamaño $size$, devuelve el máximo elemento.

        \item\mint{c}|void sumador(int* arr, int size, int c)|
        Dado un arreglo de enteros $arr$ de tamaño $size$, y un entero $c$, suma $c$ a todos los elementos de $arr$.

        \item\mint{c}|char* copiar(char* arr)|
        Crea una copia de $arr$, y devuelve un puntero a la copia.
        
        \item\mint{c}|int* reverso(int* arr, int size)|
        Dado un arreglo de enteros $arr$ de tamaño $size$, devuelve su reverso. \newline
        Ejemplo: Dado [1, -2, 85, 65] se debe devolver [65, 85, -2, 1].
        \begin{enumerate}
            \item Se puede modificar $arr$.
            \item Sin modificar $arr$.
        \end{enumerate}

        \item\mint{c}|bool estaOrdenado(int* arr, int size)|
        Dado un arreglo $arr$ de enteros de tamaño $size$, retorna true si es monótonamente creciente o monótonamente decreciente.

        \item\mint{c}|bool esPalindromo(char* s)|
        Dado un string $s$, retorna true si es un palíndromo. \textit{Recuerden que un palíndromo es una palabra que se lee igual en un sentido que en otro (por ejemplo; Ana, Anna, Otto).}
    \end{enumerate}

    % Ejercicios de searching and sorting
    \section{Búsqueda y Ordenamiento}

    \item Dado un arreglo de enteros $arr$, escribir una función que lo ordene de menor a mayor y dar su complejidad temporal.
    \begin{enumerate}
     \item Utilizando \textbf{\textit{selection sort}}.
     \item Utilizando \textbf{\textit{insertion sort}}. 
    \end{enumerate}

    \item Dado un arreglo de enteros $arr$  y un entero $target$,
    escribir una función que busque al $target$ en $arr$. Si existe, entonces devolver su índice. En caso contrario, devolver -1.

    \item Repetir el ejercicio anterior, pero ahora suponiendo que $arr$ está ordenado. El algoritmo debe tener complejidad $O(log{}n)$.
    
\end{enumerate}


\chapter{Recursividad}

\chapter{Lectura de Archivos}

% Algunos ejercicios con punteros dobles
\chapter{Magia con Punteros}

\begin{enumerate}

    \item\begin{minted}{c}
typedef struct Persona {
    char* nombre;
    char* apellido;
    char* domicilio;
    int edad;
} Persona;

char* masGrande(Persona** personas, int n)
{
    // COMPLETAR
}
    \end{minted}

    Completar la función $masGrande$, que dado un arreglo de n personas, devuelve el nombre de la persona de mayor edad.

    \item \mint{c}|void imprimirMatriz(int** matriz, int n, int m)|
    Dada una matriz de $n$ filas y $m$ columnas, imprimir todos sus elementos en pantalla. Se deben imprimir todos los elementos de la primer fila, luego todos los de la segunda fila, y así sucesivamente. Por ejemplo, dada la matriz de $2x3$ [[1,2,3], [4,5,6]], se debe imprimir 1, 2, 3, 4, 5, 6.
    
    \item \mint{c}|void traspuesta(int** matrix, int n)|
    Dada una matriz cuadrada de $nxn$, modificarla para obtener su traspuesta. Por ejemplo, dada la matriz cuadrada [[1,2], [3,4]], se debe modificar para obtener [[1, 3], [2, 4]]. \textit{Recuerden que la matriz traspuesta es aquella que surge como resultado de realizar un cambio de columnas por filas y filas por columnas en la matriz original.}
    
\end{enumerate}


\part{Estructuras de Datos}
\chapter{Listas}

\chapter{Pilas}

\chapter{Colas}

\chapter{Heaps}

\chapter{Árboles}

\chapter{Grafos}

\chapter{Hashing}

\printbibliography{}

\end{document}
